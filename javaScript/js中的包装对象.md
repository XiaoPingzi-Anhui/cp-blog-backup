<!-- category: "javaScript"
labels: "javaScript"
createdAt: 2021-03-21T13:12:03.015+00:00 -->
对于js的原始类型，你可能已经习惯了使用一些方法去访问他们，例如string的toUpperCase()，number的toFixed()等，直接通过方法操作原始类型给我们提供了很大的便利。但是，这是如何实现的呢？原始类型不是对象，如果你打印一个字符串就可以发现，上面没有任何的方法。原始类型就应该是简简单单的，轻量级的。
一方面想要原始类型轻量简单，一方面又希望可以通过各种方法访问它，这就是个悖论，js的解决方案就是包装对象，也叫“对象包装器”。
“对象包装器”对于每种原始类型都是不同的，它们被称为 String、Number、Boolean、Symbol 和 BigInt。null和undefined没有包装对象。其实我们在《基础类型转换》中已经提到过了，可以使用String(a),将a转换成字符串。你也可能见过使用new String()的方式去创建一个string变量，但这是不推荐的，因为这种方式创建出来的其实是一个对象！这样创建出来的变量在if里永远为真，与基础类型间的判等永远为false，这会给你的程序带来很多问题。
```typescript
console.log(typeof  '222'); // string
console.log(typeof  new String('222')); // object
```
但是！对象有自己的访问方法，是不是就变得很合理了。原始类型没有，但是我原始类型对应的包装对象有！str.toUpperCase()时，其实发生了这样的事：
1. 字符串 str 是一个原始值。因此，在访问其属性时，js会自动创建一个包含字符串字面值的特殊对象
2. 该方法运行并返回一个新的字符串
3. 特殊对象被销毁，只留下原始值 str。
这就是原始类型也可以通过方法访问的原因。